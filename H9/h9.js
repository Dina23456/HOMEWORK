// ==============================================
//   -  Створити функцію конструктор для об'єкту який описує теги
// Властивості
// -назва тегу
// - опис його дій
// - масив з атрибутами (2-3 атрибути максимум)
// Кожен атрибут описати як окремий який буде містити
// -назву атрибуту
// -опис дії атрибуту
// інформацію брати з htmlbook.ru
//
// Таким чином описати теги
// -a
// -div
// -h1
// -span
// -input
// -form
// -option
// -select
function tag(titleOfTag, action, attr) {
  this.titleT = titleOfTag;
  this.actionT = action;
  this.attrsT = attr;
}
let getTag_a2 = new tag('a', 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы.', [{name: 'accesskey', description: 'Активация ссылки с помощью комбинации клавиш.'}, {name: 'coords', description: 'Устанавливает координаты активной области.'}]);
console.log(getTag_a2);
let getTag_div2 = new tag('div', 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.', [{name: 'align', description: 'Задает выравнивание содержимого тега <div>.'}, {name: 'title', description: 'Добавляет всплывающую подсказку к содержимому.'}]);
console.log(getTag_div2);
let getTag_h12 = new tag('h1', 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.', [{name: 'align', description: 'Определяет выравнивание заголовка.'
}, {name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}]);
console.log(getTag_h12);
let getTag_input2 = new tag('input', 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем.', [{name: 'accept', description: 'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.'
}, {name: 'accesskey', description: 'Переход к элементу с помощью комбинации клавиш.'}]);
console.log(getTag_input2);
let getTag_span2 = new tag('span', 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.', [{name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}, {name: 'accesskey', description: 'Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.'}]);
console.log(getTag_span2);
let getTag_form2 = new tag('form', 'Связывает поле с формой по её идентификатору. Такая связь необходима в случае, когда поле располагается за пределами <form>, например, при создании её программно или по соображениям дизайна.');
console.log(getTag_form2);
let getTag_option2 = new tag('option', 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.', [{name: 'disabled', description: 'Заблокировать для доступа элемент списка.'}, {name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}]);
console.log(getTag_option2);
let getTag_select2 = new tag('select', 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.', [{name: 'autofocus', description: 'Устанавливает, что список получает фокус после загрузки страницы.'}, {name: 'accesskey', description: 'Позволяет перейти к списку с помощью некоторого сочетания клавиш.'}]);
console.log(getTag_select2);

// Приклад результату
// {
//   titleOfTag: 'area',
//     action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
//   attrs: [
//   {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
//   {/*some props and values*/},
//   {/*...*/},
//   {/*...*/},
// ]
//
// }
// ==============================================
//
//
// ==============================================
//   -  Створити класс  для об'єкту який описує теги
// Властивості
// -назва тегу
// - опис його дій
// - масив з атрибутами (2-3 атрибути максимум)
// Кожен атрибут описати як окремий який буде містити
// -назву атрибуту
// -опис дії атрибуту
// інформацію брати з htmlbook.ru
//
// Таким чином описати теги
// -a
// -div
// -h1
// -span
// -input
// -form
// -option
// -select
// Приклад результату
// {
//   titleOfTag: 'area',
//     action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
//   attrs: [
//   {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
//   {/*some props and values*/},
//   {/*...*/},
//   {/*...*/},
// ]
//
// }
// ==============================================

class tag2 {
  constructor(titleOfTag, action, attr) {
    this.titleT = titleOfTag;
    this.actionT = action;
    this.attrsT = attr;
  }
}

let getTag_a = new tag2('a', 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы.', [{name: 'accesskey', description: 'Активация ссылки с помощью комбинации клавиш.'}, {name: 'coords', description: 'Устанавливает координаты активной области.'}]);
console.log(getTag_a);
let getTag_div = new tag2('div', 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.', [{name: 'align', description: 'Задает выравнивание содержимого тега <div>.'}, {name: 'title', description: 'Добавляет всплывающую подсказку к содержимому.'}]);
console.log(getTag_div);
let getTag_h1 = new tag2('h1', 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.', [{name: 'align', description: 'Определяет выравнивание заголовка.'}, {name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}]);
console.log(getTag_h1);
let getTag_input = new tag2('input', 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем.', [{name: 'accept', description: 'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.'}, {name: 'accesskey', description: 'Переход к элементу с помощью комбинации клавиш.'}]);
console.log(getTag_input);
let getTag_span = new tag2('span', 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.', [{name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}, {name: 'accesskey', description: 'Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.'}]);
console.log(getTag_span);
let getTag_form = new tag2('form', 'Связывает поле с формой по её идентификатору. Такая связь необходима в случае, когда поле располагается за пределами <form>, например, при создании её программно или по соображениям дизайна.');
console.log(getTag_form);
let getTag_option = new tag2('option', 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.', [{name: 'disabled', description: 'Заблокировать для доступа элемент списка.'}, {name: 'class', description: 'Определяет имя класса, которое позволяет связать тег со стилевым оформлением.'}]);
console.log(getTag_option);
let getTag_select = new tag2('select', 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.', [{name: 'autofocus', description: 'Устанавливает, что список получает фокус после загрузки страницы.'}, {name: 'accesskey', description: 'Позволяет перейти к списку с помощью некоторого сочетания клавиш.'}]);
console.log(getTag_select);

// ==============================================
//   - Створити об'єкт car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль ""
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================
let car11 = {
  model: 'ADFHG',
  producer: 'BMW',
  year: 2003,
  maxspeed: 300,
  volume: 5.07,
  drive() {
    console.log(`Їдемо зі швидкістю ${this.maxspeed} на годину!`);
  },
  info() {
    console.log(`модель: ${this.model}; виробник: ${this.producer};рік випуску: ${this.year};максимальна швидкість: ${this.maxspeed};об'єм двигуна: ${this.volume};`);
  },
  changeYear(newValue) {
    this.year = (newValue)
  },
  increaseMaxSpeed(newSpeed) {
    this.maxspeed = newSpeed;
  },
  addDriver(driver) {
    this.driver = driver;
  }
}
car11.drive();
car11.info();
car11.increaseMaxSpeed(150);
car11.changeYear(2015);
car11.addDriver('Bogdan');
console.log(car11);

// ==============================================
//   - Створити функцію конструктор яка дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================
function cars(model, producer, year, maxspeed, volume) {
  this.model = model;
  this.producer = producer;
  this.year = year;
  this.maxspeed = maxspeed;
  this.volume = volume;

  this.drive = function () {
    return console.log('їдемо зі швидкістю' + maxspeed + ' на годину');
  }
  this.info = function () {
    return console.log(`модель: ${this.model}; виробник: ${this.producer};рік випуску: ${this.year};максимальна швидкість: ${this.maxspeed};об'єм двигуна: ${this.volume};`)
  }
  this.increaseMaxSpeed = function (newSpeed) {
    return maxspeed === newSpeed;
  }
  this.changeYear = function (newValue) {
    return this.year = newValue;
  }
  this.addDriver = function (driver) {
    return driver;
  }
};

let cars1 = new cars('bMW', 'Germany', 2001, 220, 2.2);
cars1.drive();
cars1.info();
cars1.increaseMaxSpeed(100);
cars1.changeYear(2018);
cars1.addDriver('Vova');
console.log(cars1);


// ==============================================
//   - Створити клас який дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================
class cars {
  constructor(model, producer, year, maxspeed, volume) {
    this.model = model;
    this.producer = producer;
    this.year = year;
    this.maxspeed = maxspeed;
    this.volume = volume;

    this.drive = function () {
      return console.log('їдемо зі швидкістю' + maxspeed + ' на годину');
    }
    this.info = function () {
      return console.log(`модель: ${this.model}; виробник: ${this.producer};рік випуску: ${this.year};максимальна швидкість: ${this.maxspeed};об'єм двигуна: ${this.volume};`)
    }
    this.increaseMaxSpeed = function (newSpeed) {
      return maxspeed === newSpeed;
    }
    this.changeYear = function (newValue) {
      return this.year = newValue;
    }
    this.addDriver = function (driver) {
      return driver;
    }
  }
};

let cars1 = new cars('bMW', 'Germany', 2001, 220, 2.2);
cars1.drive();
cars1.info();
cars1.increaseMaxSpeed(100);
cars1.changeYear(2018);
cars1.addDriver('Vova');
console.log(cars1);
// ==============================================
//   -створити класс попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт класу "принц" за допомоги класу який має поля ім'я, вік, туфелька яку він знайшов.
// -- за допоиоги циклу знайти яка попелюшка повинна бути з принцом
// ==============================================
//
class cinderela {
  constructor(name, age, sizefoot) {
    this.name = name;
    this.age = age;
    this.sizefoot = sizefoot;
  }
}
let cinderela_1 = new cinderela('anna', 19, 35);
let cinderela_2 = new cinderela('maria', 15, 32);
let cinderela_3 = new cinderela('Angelina', 19, 33);
let cinderela_4 = new cinderela('Re', 17, 32);
let cinderela_5 = new cinderela('Katia', 14, 33);
let cinderela_6 = new cinderela('Sofia', 18, 32);
let cinderela_7 = new cinderela('Karina', 19, 33);
let cinderela_8 = new cinderela('Victoria', 17, 33);
let cinderela_9 = new cinderela('maria', 12, 32);
let cinderela_10 = new cinderela('Olenka', 16, 33);
let cinder = [cinderela_1, cinderela_2, cinderela_3, cinderela_4, cinderela_5, cinderela_6, cinderela_7, cinderela_8, cinderela_9, cinderela_10];
function prince(name, age, sizefoot) {
  this.name = name;
  this.age = age;
  this.sizefoot = sizefoot;
}
let prince1 = new prince('Konan', 18, 40);
function search() {
  for (const i of cinder) {
    if (i.age === prince1.age) {
      console.log(prince1.name + ' повинен бути з ' + i.name)
    }
  }
}
search();
// ==============================================
//   -створити функцію конструктор попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт типу "принц" за допомоги функції конструктора з полями ім'я, вік, туфелька яку він знайшов, та функцію "пошук попелюшки"
// -- функція повинна приймати масив попелюшок, та шукає ту котра йому підходить
// ==============================================
function cinderela (name, age, sizefoot) {
    this.name = name;
    this.age = age;
    this.sizefoot = sizefoot;
}
let cinderela_1 = new cinderela('anna', 19, 35);
let cinderela_2 = new cinderela('maria', 15, 32);
let cinderela_3 = new cinderela('Angelina', 19, 33);
let cinderela_4 = new cinderela('Re', 17, 32);
let cinderela_5 = new cinderela('Katia', 14, 33);
let cinderela_6 = new cinderela('Sofia', 18, 32);
let cinderela_7 = new cinderela('Karina', 19, 33);
let cinderela_8 = new cinderela('Victoria', 17, 33);
let cinderela_9 = new cinderela('maria', 12, 32);
let cinderela_10 = new cinderela('Olenka', 16, 33);
let cinder = [cinderela_1, cinderela_2, cinderela_3, cinderela_4, cinderela_5, cinderela_6, cinderela_7, cinderela_8, cinderela_9, cinderela_10];
function prince(name, age, sizefoot) {
  this.name = name;
  this.age = age;
  this.sizefoot = sizefoot;
}
let prince1 = new prince('Konan', 18, 40);
function search() {
  for (const i of cinder) {
    if (i.age === prince1.age) {
      console.log(prince1.name + ' повинен бути з ' + i.name)
    }
  }
}
search();
